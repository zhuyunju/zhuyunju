# Numpy

## 介绍

- Numpy(Numerical Python)是一个开源的Python科学计算库，用于快速处理任意维度的数组。
- Numpy支持常见的数组和矩阵操作。对于同样的数值计算任务，使用Numpy比直接使用Python要简洁的多。
- Numpy使用ndarray对象来处理多维数组，该对象是一个快速而灵活的大数据容器。

## ndarry
numpy提供了一个n维数组

## numpy与list对比
- 1.存储风格：
        ndarray 内部存储类型相同，存储空间连续，但通用性不强

        list 内部存储类型可以不同，存储空间未必连续，通用性较强
- 2.并行化计算：ndarray支持向量化计算
- 3.底层语言：
        Numpy底层采用C语言编写，内部解除了GIL（全局解释器锁）

## 属性方法
### nadarry.shape —— 数组维度的元组

### ndarry.ndim —— 数组维数
### ndarray.size —— 数组中元素的数量
### ndarray.itemsize —— 一个数组元素的长度（字节）
### ndarray.dtype ——数组元素的类型
### 及数组名.函数名()/无

## 一、基本操作
### ndarray形状和类型
#### 形状


```python
import numpy as np
a = np.array([1,2,3,4]) # (4,)
b = np.array([[1,2,3,4],[1,2,3,4]]) #(2,4)
c = np.array([[[1,2,3,4],[1,2,3,4],[1,2,3,4]]]) # (1,3,4)
print(a.shape,b.shape,c.shape)
```

#### 类型


```python
a.dtype
```




    dtype('int32')




```python
# 创建数组的时候可以指定类型
a = np.array(a,dtype= np.float32)
a.dtype
```




    dtype('float32')




```python
#类型修改
a= a.astype(np.int32)
a.dtype
```




    dtype('int32')



### 生成数组
#### 生成0 1数组


```python
a = np.zeros(shape=(3,4),dtype="float32")
a
## 其中shape的参数为列表/元组，用于表示数组的维度（形状）
```




    array([[0., 0., 0., 0.],
           [0., 0., 0., 0.],
           [0., 0., 0., 0.]], dtype=float32)



#### 现有数组生成 



```python
#深拷贝相当于一个新矩阵，浅拷贝相当于指向拷贝对象数值会随着变化
a1 = np.array(a) # 深拷贝
a2 = np.copy(a) # 深拷贝
a3 = np.asarray(a) # 浅拷贝
a4 = a # 浅拷贝
print(a1)
print("————————")
print(a3)
```

    [[1. 1. 1. 1.]
     [1. 1. 1. 1.]
     [1. 1. 1. 1.]]
    ————————
    [[1. 1. 1. 1.]
     [1. 1. 1. 1.]
     [1. 1. 1. 1.]]
    


```python
# 验证改变原数组
a[0:3] = 1
print(a1)
print("————————")
print(a3)
```

    [[0. 0. 0. 0.]
     [0. 0. 0. 0.]
     [0. 0. 0. 0.]]
    ————————
    [[1. 1. 1. 1.]
     [1. 1. 1. 1.]
     [1. 1. 1. 1.]]
    

#### 生成固定范围的数组


```python
p1 = np.linspace(0,10,5) #生成[1,10]之前等距离的5个数，左右均为闭区间
p2 = np.arange(0,10,5) # 生成5步长数组，左开右闭
print(p1)
print("————————")
print(p2)
```

    [ 0.   2.5  5.   7.5 10. ]
    ————————
    [0 5]
    

#### 生成随机数组


```python
# 生成均匀分布的一组数[low,high] 左闭右开，size是数量
data1 = np.random.uniform(low=-1, high=1, size=100)
## size可以规定数组形状,size=(9,100)
data2 = np.random.normal(loc=1.75,scale = 0.1,size=100)
print(data1)
print("————————")
print(data2)
```

    [-0.83259221  0.53972312 -0.76786209 -0.33830533 -0.89082748  0.7573071
      0.9296487  -0.56513644  0.04889454  0.51206486 -0.92525786  0.99654704
     -0.09686469 -0.96182606  0.86938755  0.7911067   0.86817187  0.16781344
      0.91146931 -0.88811742 -0.63943759 -0.63738823 -0.1976344  -0.26145369
     -0.17310125  0.94641194  0.48507657 -0.24029759  0.20704452 -0.14051278
      0.760646   -0.74647229  0.50467226  0.59725176  0.89529786  0.87898903
      0.99030132 -0.89593298 -0.90438122  0.54347729  0.66973894 -0.84336371
     -0.65019261  0.59514538 -0.06449279  0.77384268  0.6671363   0.06514827
     -0.08168542 -0.76109406  0.72617887 -0.42483641 -0.89093862  0.77342945
     -0.29431691  0.34385339 -0.41991693 -0.77748146 -0.85683974 -0.16526808
     -0.60028711 -0.70592065  0.32897064  0.2232643   0.81589315  0.24016117
     -0.01717373 -0.10126123 -0.53887715  0.97336139  0.18575343  0.2164841
     -0.62978306 -0.21452712 -0.095221   -0.73646163 -0.59043614 -0.59484837
      0.93995172 -0.26423977 -0.29729679 -0.69463145 -0.90147201 -0.99085221
      0.22831485  0.38280373 -0.30319285  0.82130178  0.14987991 -0.19646618
     -0.99576936 -0.47032817  0.57255057 -0.97082571  0.25994829  0.86022323
      0.4943024  -0.84915563  0.48090594  0.76850825]
    ————————
    [1.74607822 1.67132305 1.80069123 1.82573099 1.66366305 1.87341846
     1.79228325 1.68418017 1.71033707 1.79212848 1.84028161 1.8345973
     2.02743505 1.73161439 1.63509987 1.83576505 1.88584624 1.82694342
     1.66665914 1.74043446 1.7300198  1.6603629  1.68430955 1.6168779
     1.5771653  1.753435   1.73540209 1.75799134 1.77856963 1.81953571
     1.80007063 1.84896171 1.82515691 1.74919294 1.72163203 1.70746727
     1.73254743 1.70015836 1.72441008 1.72530045 1.70542664 1.54401335
     1.68586727 1.73395389 1.61601037 1.63386617 1.84481554 1.88854589
     1.8717707  1.69691158 1.7667166  1.74383062 1.80533174 1.74310789
     1.99732556 1.82341168 1.85474051 1.76703245 1.81042102 1.65206369
     1.73893516 1.77591194 1.73646224 1.50298616 1.71703389 1.73227458
     1.6380754  2.03063381 1.74999814 1.78266179 2.00587104 1.58541356
     1.72419179 1.69868284 1.62718291 1.75456179 1.75553823 1.65531259
     1.62222558 1.69863853 1.83893895 1.82047078 1.67044449 1.60234664
     1.551326   1.68033196 1.62021284 1.66471125 1.73390107 1.78888234
     1.75887633 1.78251244 1.67887015 1.85562332 1.62325204 1.83490296
     1.69807267 1.92910854 1.76229934 1.92114141]
    

#### 索引切片


```python
# 待理解
```

#### 形状改变


```python
# 创建一个数组
s1 = np.zeros((8,10))
s1
```




    array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]])




```python
s2 = s1.reshape((10,8)) # 变成了10行8列返回新的ndarray，原始数组没有改变
s2
```




    array([[0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0.]])




```python
s3 = s1.resize((10,8))# 没有返回值，对原始数组进行了修改
print(s3)
print("-------------")
print(s1)
```

    None
    -------------
    [[0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0.]]
    


```python
s4 = s1.T   #转置 行变列，列变黄 返回一个对象 原数组未改变

```




    array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]])



#### 数组去重


```python
q1 = np.array([[1,2,3,4],[1,2,3,4]])
np.unique(q1) # 数组去重
```




    array([1, 2, 3, 4])



## 二、ndarray运算

### 逻辑运算

#### 运算符


```python
c1 = np.array([[1,1,1,2,3,4,5,6],[1,1,1,2,3,4,5,6]])
# 逻辑判断，大于1标记为True，否则false
c1 > 1 #返回一个True、false矩阵
c1[c1>1] = 0 # 将>1的全部改为0
c1
```




    array([[1, 1, 1, 0, 0, 0, 0, 0],
           [1, 1, 1, 0, 0, 0, 0, 0]])



#### 通用判断函数


```python
# 以下两者均只返回一个布尔值
np.all(c1 > 1)   # 全部是true则返回一个true，否则flase
np.any(c1 == 0)  # 相反有一个true则返回true
```




    True



#### 三元运算符


```python
#  np.where(布尔值，True的位置的值，False的位置的值)
np.where(c1 == 0,1,3) # 等于0的话则为1，不等于则为3
```




    array([[3, 3, 3, 1, 1, 1, 1, 1],
           [3, 3, 3, 1, 1, 1, 1, 1]])



#### 统计运算符

- min,max,mean(均值),median(中位数),var(方差),std(标准差)
- 使用方法：np.函数名(数组名) 或 数组名.方法名
- 同时应当注意 axis的使用。 axis=0表示列 axis=1表示行 axis=-1 表示最后一维度


```python
### 返回最大值
c1.max() # 返回最大值
```




    1




```python
np.max(c1,axis=1) # 返回一个向量，所有行的最大值
```




    array([1, 1])




```python
### 返回最大值索引
np.argmax(c1,axis=0)
### np.argmin返回最小值索引
```




    array([0, 0, 0, 0, 0, 0, 0, 0], dtype=int64)



### 数组间运算


```python
# 正常的运算即可 加减乘除等
arr = np.array([[1, 2, 3, 2, 1, 4], [5, 6, 1, 2, 3, 1]])
arr / 10
```




    array([[0.1, 0.2, 0.3, 0.2, 0.1, 0.4],
           [0.5, 0.6, 0.1, 0.2, 0.3, 0.1]])



#### 广播机制 
执行broadcast的前提在于，两个nadarray执行的是element-wise的运算，Broadcast
机制的功能是为了方便不同形状的ndarray(numpy库的核心数据结构)进行数学运算。

当操作两个数组时，numpy会逐个比较它们的shape(构成的元组tuple)，只有在
下述情况下，两个数组才能够进行数组与数组的运算。

- 维度相等
- shape（其中相对应的一个地方为1）

### 矩阵运算
英文matrix，和array的区别是矩阵必须是2维的，但是array可以是多维的。

矩阵和二维数组的区别？

np.mat() 将数组转换成矩阵类型

矩阵乘法规则（M行,N列）x (N行,L列) = (M行,L列)


```python
data1 = np.array([[1,2,3,4,5],[1,2,3,4,5]])
data2 = np.array([[6,7,8,9,10],[6,7,8,9,10]])
data2 = data2.reshape(5,2)
# 数组相乘必须遵守 - 矩阵乘法规则（M行,N列）x (N行,L列) = (M行,L列)
np.dot(data1,data2)
```




    array([[125, 125],
           [125, 125]])




```python
np.matmul(data1,data2)
```




    array([[125, 125],
           [125, 125]])




```python
### array必须借用np.函数而martix则不用可以直接相乘
data1 = np.mat(data1)
data2 = np.mat(data2)
#data1 * data2
```




    matrix([[ 6,  7],
            [ 8,  9],
            [10,  6],
            [ 7,  8],
            [ 9, 10]])



### 合并、分割
numpy.hstack 水平拼接

numpy.vstack 竖拼接

numpy.concatenate((a1,a2),axis=0) 水平|竖拼接


```python
# 分割
np.split(data1,2) # 分两份
np.split(data1,[0,1,4]) # 按索引分割
```




    [array([], shape=(0, 5), dtype=int32),
     array([[1, 2, 3, 4, 5]]),
     array([[1, 2, 3, 4, 5]]),
     array([], shape=(0, 5), dtype=int32)]



## IO操作与数据处理（了解）
### 读取数据
- np的数据处理无法识别字符串


```python
np.genfromtxt("test.csv", delimiter=",") # 会有问题，读不出字符串 造成缺失
```
